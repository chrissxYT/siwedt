#!/usr/bin/env node

const fs = require('fs');
const css = require('csso').minify;
const babel = require('@babel/core');
const html = require('html-minifier').minify;
const walk = require('ignore-walk');
const minimist = require('minimist');

const dirWithSlash = d => d.endsWith('/') ? d : d + '/';

const args = minimist(process.argv.slice(2));

const indir = dirWithSlash(args['_'][0] ?? '.');
const rc = args['inline-config'] ?? fs.readFileSync(args['c'] ?? args['config'] ?? indir + '.siwedtrc');
const browserlist = rc['browserlist'];
const outdir = dirWithSlash(rc['outdir'] ?? 'dist');

babel.loadOptions({
    'presets': [
        [require('@babel/preset-env'), {'targets': browserlist}],
        [require('babel-preset-minify')],
    ],
});

if(fs.existsSync(outdir)) fs.rmSync(outdir, {recursive: true, force: true});

// .siwedtignore shouldn't exist, blame @isaacs: npm/ignore-walk#12
const files = walk.sync({path: indir, ignoreFiles: ['.gitignore', '.siwedtignore']});
for(const f of files) {
    const o = outdir + f;
    const od = o.split('/').slice(0, -1).reduce((x, y) => x + '/' + y);
    if(!fs.existsSync(od)) fs.mkdirSync(od, {recursive: true});
    console.log(f);
    if (f.endsWith('.js')) {
        fs.writeFileSync(o, babel.transformFileSync(f).code);
    } else if (f.endsWith('.css')) {
        fs.writeFileSync(o, css(fs.readFileSync(f, {encoding: 'utf-8'})).css);
    } else if (f.endsWith('.html') || f.endsWith('.htm')) {
        fs.writeFileSync(o, html(fs.readFileSync(f, {encoding: 'utf-8'})));
    } else {
        fs.copyFileSync(f, o);
    }
}
